<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proxima 8</title>
    <link rel="icon" type="image/png" href="assets/icon-192.png">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f8f9fa;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #212529;
        }
        h1 { font-weight: 200; color: #343a40; display: flex; align-items: center; gap: 15px; margin-bottom: 10px; letter-spacing: 2px; text-transform: uppercase; }
        
        #controls-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            color: #888;
        }
        .text-btn {
            cursor: pointer;
            transition: color 0.2s, opacity 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            opacity: 0.4;
        }
        .text-btn:hover { color: #333; opacity: 1; }
        .text-btn.highlight {
            opacity: 1;
            color: #40c057;
            font-weight: 800;
            transform: scale(1.1);
        }
        
        #grid {
            display: grid;
            grid-gap: 10px;
            background: #fff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            max-width: 95vw;
            overflow: auto;
        }
        .cell {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.2s ease;
            background-color: #e9ecef;
            border: 4px solid transparent;
            user-select: none;
            box-sizing: border-box;
            background-clip: padding-box;
            padding: 4px;
        }
        .cell.active {
            background-color: #4dabf7 !important;
            color: white !important;
            box-shadow: 0 2px 8px rgba(77, 171, 247, 0.4);
            background-clip: content-box;
        }
        .cell.override {
            background-color: #fab005 !important;
            color: white !important;
            box-shadow: 0 0 15px rgba(250, 176, 5, 0.6);
            background-clip: padding-box !important;
        }
        .cell.correct {
            border-color: #40c057;
            box-shadow: inset 0 0 10px rgba(64, 192, 87, 0.5);
        }
        .cell.too-many {
            border-color: #fa5252;
            box-shadow: inset 0 0 10px rgba(250, 82, 82, 0.5);
            color: #fa5252;
        }
        #status {
            margin-top: 20px;
            font-weight: 500;
        }
        .menu-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s;
            width: 80px;
        }
        .menu-item:hover { transform: translateY(-5px); }
        .menu-item.completed .menu-box {
            background-color: #ebfbee;
            border-color: #40c057;
            color: #2b8a3e;
        }
        .menu-item.completed .menu-box::after {
            content: "‚úì";
            position: absolute;
            top: -5px;
            right: -5px;
            background: #40c057;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
            z-index: 2;
        }
        .menu-item.in-progress .menu-box {
            border-color: #4dabf7;
            border-style: dashed;
        }
        .menu-box {
            position: relative;
            width: 70px;
            height: 70px;
            background: #fff;
            border: 4px solid #e9ecef;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            margin-bottom: 8px;
            padding: 8px;
            box-sizing: border-box;
            text-align: center;
            font-size: 10px;
            line-height: 1.2;
            word-wrap: break-word;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .menu-label {
            display: none;
        }
        #level-menu {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 800px;
        }
        .cat-title {
            width: 100%;
            text-align: center;
            margin-top: 30px;
            color: #555;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        
        #settings-toggle { 
            cursor: pointer; 
            font-size: 20px; 
            position: absolute; 
            top: 20px; 
            right: 20px; 
            opacity: 0.4; 
            transition: opacity 0.2s; 
            user-select: none;
            color: #333;
            filter: grayscale(100%);
        }
        #settings-toggle:hover { opacity: 1; }
        
        #settings-panel {
            display: none;
            position: absolute;
            top: 60px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 100;
            width: 200px;
        }
        #settings-panel button {
            width: 100%;
            margin-top: 10px;
            padding: 10px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <h1 id="main-header">Proxima 8</h1>

    <div id="controls-row">
        <span id="back-btn" class="text-btn" onclick="showMenu()" style="display: none;">‚Üê Exit</span>
        <span id="undo-btn" class="text-btn" onclick="undoMove()" style="display: none;">‚Ü© Undo</span>
        <span id="reset-btn" class="text-btn" onclick="resetGame()" style="display: none;">‚Ü∫ Clear</span>
        <span id="next-btn" class="text-btn" onclick="nextLevel()" style="display: none;">‚Üí Next</span>
    </div>
    
    <div id="settings-toggle" onclick="toggleSettings()" title="Settings">‚öô</div>
    <div id="help-toggle" onclick="toggleHelp()" style="cursor: pointer; font-size: 20px; position: absolute; top: 20px; right: 55px; opacity: 0.4; transition: opacity 0.2s; user-select: none; color: #333;" title="How to Play">?</div>

    <div id="settings-panel">
        <h3 style="margin-top: 0;">Settings</h3>
        <button onclick="clearAllProgress()" style="background: #fa5252; color: white;">Reset All Neural Mapping</button>
        <button onclick="toggleSettings()" style="background: #e9ecef; color: #333;">Close</button>
    </div>

    <div id="help-panel" style="display: none; position: absolute; top: 60px; right: 20px; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 100; width: 280px; font-size: 14px; line-height: 1.5;">
        <h3 style="margin-top: 0;">Protocol</h3>
        <p><strong>Objective:</strong> Identify the hidden neural pattern by satisfying all proximity clues.</p>
        <p><strong>Clues:</strong> Each number indicates the exact count of active nodes in its proximity (the surrounding cells).</p>
        <p><strong>Feedback:</strong></p>
        <ul style="padding-left: 20px;">
            <li><span style="color: #40c057; font-weight: bold;">Green:</span> Proximity satisfied.</li>
            <li><span style="color: #fa5252; font-weight: bold;">Red:</span> Over-saturated (too many neighbors).</li>
            <li><span style="color: #888; font-weight: bold;">Grey:</span> Under-saturated (needs more neighbors).</li>
        </ul>
        <button onclick="toggleHelp()" style="width: 100%; margin-top: 10px; padding: 10px; border-radius: 6px; border: none; cursor: pointer; font-weight: 600; background: #e9ecef; color: #333;">Close</button>
    </div>
    
    <div id="level-menu"></div>

    <div id="game-view" style="display: none; flex-direction: column; align-items: center;">
        <div id="grid"></div>
        <div id="status">Map the proximities</div>
        <div id="action-row" style="margin-top: 15px; display: flex; gap: 10px;">
            <div id="share-controls" style="display: none; gap: 10px;">
                <button onclick="shareResult()" style="padding: 8px 16px; border-radius: 20px; border: 1px solid #4dabf7; background: white; color: #4dabf7; cursor: pointer; font-weight: 600;">Share Mapping</button>
            </div>
            <button id="override-btn" onclick="requestOverride()" style="padding: 8px 16px; border-radius: 20px; border: 1px solid #fab005; background: white; color: #fab005; cursor: pointer; font-weight: 600;">Neural Override (3)</button>
        </div>
        <div id="level-id-display" onclick="copyUID()" style="cursor: pointer; font-size: 10px; color: #ccc; margin-top: 10px; font-family: monospace;" title="Click to copy UID"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script>
        function toggleSettings() {
            const panel = document.getElementById('settings-panel');
            const isHidden = window.getComputedStyle(panel).display === 'none';
            panel.style.display = isHidden ? 'block' : 'none';
            if (isHidden) document.getElementById('help-panel').style.display = 'none';
        }

        function toggleHelp() {
            const panel = document.getElementById('help-panel');
            const isHidden = window.getComputedStyle(panel).display === 'none';
            panel.style.display = isHidden ? 'block' : 'none';
            if (isHidden) document.getElementById('settings-panel').style.display = 'none';
        }

        function clearAllProgress() {
            if (confirm("Reset all neural mapping?")) {
                localStorage.removeItem('zen_completed');
                localStorage.removeItem('zen_in_progress');
                toggleSettings();
                showMenu();
            }
        }

        let levelManifest = [];
        const levelsCache = {};

        let currentLevel = null;
        let state = [];
        let history = [];
        let overridesLeft = 3;
        let overridePending = [];

        async function fetchManifest() {
            try {
                const response = await fetch('manifest.json');
                if (response.ok) {
                    levelManifest = await response.json();
                }
            } catch (e) { console.error("Could not load manifest", e); }
        }

        function getCompleted() {
            return JSON.parse(localStorage.getItem('zen_completed') || '[]');
        }

        function saveInProgress(id, state) {
            const hasActiveCells = state.some(row => row.some(cell => cell === 1));
            let inProgress = JSON.parse(localStorage.getItem('zen_in_progress') || '{}');
            if (hasActiveCells) {
                inProgress[id] = state;
                // Only unmark if the NEW state isn't a winning state anymore
                // (Handled by checkWin called right after saveInProgress)
            }
            else {
                delete inProgress[id];
                unmarkCompleted(id);
            }
            localStorage.setItem('zen_in_progress', JSON.stringify(inProgress));
        }

        function getInProgress(id) {
            let inProgress = JSON.parse(localStorage.getItem('zen_in_progress') || '{}');
            return inProgress[id];
        }

        function clearInProgress(id) {
            let inProgress = JSON.parse(localStorage.getItem('zen_in_progress') || '{}');
            delete inProgress[id];
            localStorage.setItem('zen_in_progress', JSON.stringify(inProgress));
        }

        function markCompleted(id) {
            let completed = getCompleted();
            if (!completed.includes(id)) {
                completed.push(id);
                localStorage.setItem('zen_completed', JSON.stringify(completed));
            }
            // Save the final winning state so it persists when re-opened
            let inProgress = JSON.parse(localStorage.getItem('zen_in_progress') || '{}');
            inProgress[id] = state;
            localStorage.setItem('zen_in_progress', JSON.stringify(inProgress));
            
            document.getElementById('share-controls').style.display = 'flex';
            document.getElementById('override-btn').style.display = 'none';
        }

        function unmarkCompleted(id) {
            let completed = getCompleted();
            completed = completed.filter(item => item !== id);
            localStorage.setItem('zen_completed', JSON.stringify(completed));
        }

        function showMenu() {
            window.history.pushState({}, '', window.location.pathname);
            document.getElementById('main-header').innerText = "Proxima 8";
            
            document.getElementById('back-btn').style.display = 'none';
            document.getElementById('undo-btn').style.display = 'none';
            document.getElementById('reset-btn').style.display = 'none';
            
            document.getElementById('level-menu').style.display = 'flex';
            document.getElementById('game-view').style.display = 'none';
            initMenu();
        }

        function initMenu() {
            const menuEl = document.getElementById('level-menu');
            if (!menuEl) return;
            menuEl.innerHTML = '';
            const completed = getCompleted();
            const inProgress = JSON.parse(localStorage.getItem('zen_in_progress') || '{}');

            const categories = [
                { name: 'Neural Sync (3x3)', filter: (l) => l.width === 3 },
                { name: 'Local Mapping (5x5)', filter: (l) => l.width === 5 },
                { name: 'Regional Analysis (10x10)', filter: (l) => l.width === 10 },
                { name: 'Global Resolution (15x15)', filter: (l) => l.width === 15 }
            ];

            categories.forEach(cat => {
                const allInCat = levelManifest.filter(cat.filter);

                if (allInCat.length > 0) {
                    const header = document.createElement('h2');
                    header.className = 'cat-title';
                    header.innerText = cat.name;
                    menuEl.appendChild(header);

                    allInCat.forEach(level => {
                        const item = document.createElement('div');
                        item.className = 'menu-item';
                        if (completed.includes(level.id)) item.classList.add('completed');
                        else if (inProgress[level.id]) item.classList.add('in-progress');
                        
                        item.onclick = () => loadLevel(level.id);
                        item.innerHTML = `
                            <div class="menu-box">${level.title || level.name}</div>
                        `;
                        menuEl.appendChild(item);
                    });
                }
            });
        }

        async function loadLevel(key) {
            if (!key) return showMenu();

            let levelData = levelsCache[key];
            if (!levelData || !levelData.clues) {
                try {
                    const response = await fetch(`levels/${key}.json`);
                    if (response.ok) {
                        const fetched = await response.json();
                        levelData = {
                            ...fetched,
                            id: key,
                            title: fetched.name || "Mapping",
                            display: fetched.display || `${fetched.width}x${fetched.height}`,
                            targetActive: fetched.solution ? fetched.solution.flat().reduce((a, b) => a + b, 0) : 0
                        };
                        levelsCache[key] = levelData;
                    }
                } catch (e) { console.error(e); }
            }

            if (!levelData || !levelData.clues) return showMenu();

            currentLevel = levelData;
            document.getElementById('main-header').innerText = currentLevel.title;
            
            document.getElementById('back-btn').style.display = 'flex';
            document.getElementById('undo-btn').style.display = 'flex';
            document.getElementById('reset-btn').style.display = 'flex';
            document.getElementById('next-btn').style.display = 'flex';
            document.getElementById('next-btn').classList.remove('highlight');
            
            const saved = getInProgress(key);
            state = saved ? saved : Array(currentLevel.height).fill().map(() => Array(currentLevel.width).fill(0));
            history = [];

            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('level') !== key) {
                window.history.pushState({}, '', `?level=${key}`);
            }

            document.getElementById('level-menu').style.display = 'none';
            document.getElementById('game-view').style.display = 'flex';
            document.getElementById('level-id-display').innerText = `UID: ${key}`;
            document.getElementById('status').innerText = "Map the proximities";
            document.getElementById('share-controls').style.display = 'none';
            document.getElementById('override-btn').style.display = 'block';
            overridePending = [];
            updateOverrideButton();
            
            createGrid();
            updateUI();
        }

        function createGrid() {
            if (!currentLevel || !currentLevel.clues) return;
            const gridEl = document.getElementById('grid');
            const cellSize = currentLevel.width > 10 ? '35px' : '50px';
            const fontSize = currentLevel.width > 10 ? '14px' : '18px';
            const gap = currentLevel.width > 10 ? '5px' : '10px';
            
            gridEl.style.gridGap = gap;
            gridEl.style.gridTemplateColumns = `repeat(${currentLevel.width}, ${cellSize})`;
            gridEl.innerHTML = '';
            
            for (let y = 0; y < currentLevel.height; y++) {
                for (let x = 0; x < currentLevel.width; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.style.width = cellSize;
                    cell.style.height = cellSize;
                    cell.style.fontSize = fontSize;
                    cell.id = `cell-${x}-${y}`;
                    cell.innerText = currentLevel.clues[y][x];
                    cell.onclick = () => toggleCell(x, y);
                    gridEl.appendChild(cell);
                }
            }
            checkWin(true);
        }

        function toggleCell(x, y) {
            history.push(JSON.stringify(state));
            if (history.length > 50) history.shift();
            state[y][x] = state[y][x] === 0 ? 1 : 0;
            
            // Clear override if this cell was highlighted
            overridePending = overridePending.filter(p => p.x !== x || p.y !== y);
            
            saveInProgress(currentLevel.id, state);
            updateUI();
            checkWin();
        }

        function undoMove() {
            if (history.length === 0) return;
            state = JSON.parse(history.pop());
            saveInProgress(currentLevel.id, state);
            updateUI();
            checkWin();
        }

        function updateUI() {
            if (!currentLevel) return;
            for (let y = 0; y < currentLevel.height; y++) {
                for (let x = 0; x < currentLevel.width; x++) {
                    const cell = document.getElementById(`cell-${x}-${y}`);
                    if (!cell) continue;
                    
                    if (state[y][x] === 1) cell.classList.add('active');
                    else cell.classList.remove('active');

                    // Apply persistent override highlight
                    const isOverridden = overridePending.some(p => p.x === x && p.y === y);
                    if (isOverridden) cell.classList.add('override');
                    else cell.classList.remove('override');
                }
            }
        }

        function checkWin(silent = false) {
            if (!currentLevel) return;
            let solved = true;
            let totalActive = 0;
            const targetActive = currentLevel.targetActive || (currentLevel.solution ? currentLevel.solution.flat().reduce((a, b) => a + b, 0) : 0);

            for (let y = 0; y < currentLevel.height; y++) {
                for (let x = 0; x < currentLevel.width; x++) {
                    if (state[y][x] === 1) totalActive++;
                    let neighbors = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            let nx = x + dx, ny = y + dy;
                            if (nx >= 0 && nx < currentLevel.width && ny >= 0 && ny < currentLevel.height) {
                                if (state[ny][nx] === 1) neighbors++;
                            }
                        }
                    }
                    const cell = document.getElementById(`cell-${x}-${y}`);
                    if (!cell) continue;
                    
                    if (neighbors === currentLevel.clues[y][x]) {
                        cell.classList.add('correct');
                        cell.classList.remove('too-many');
                    } else {
                        cell.classList.remove('correct');
                        if (neighbors > currentLevel.clues[y][x]) cell.classList.add('too-many');
                        else cell.classList.remove('too-many');
                        solved = false;
                    }
                }
            }

            // If a target count exists, must match exactly.
            // If not, just needs at least one active cell (prevents empty board win).
            const isActuallySolved = targetActive > 0 ? (solved && totalActive === targetActive) : (solved && totalActive > 0);

            if (isActuallySolved) {
                console.log("LEVEL SOLVED", { id: currentLevel.id, totalActive, solved });
                const statusEl = document.getElementById('status');
                if (statusEl.innerText !== "Origin Identified") {
                    statusEl.innerText = "Origin Identified";
                    document.getElementById('next-btn').classList.add('highlight');
                    if (!silent) {
                        confetti({
                            particleCount: 150,
                            spread: 70,
                            origin: { y: 0.6 },
                            colors: ['#4dabf7', '#40c057', '#fab005']
                        });
                    }
                }
                markCompleted(currentLevel.id);
            } else {
                if (!silent) {
                    document.getElementById('status').innerText = "Map the proximities";
                    document.getElementById('share-controls').style.display = 'none';
                    document.getElementById('override-btn').style.display = 'block';
                }
                unmarkCompleted(currentLevel.id);
            }
        }

        function updateOverrideButton() {
            const btn = document.getElementById('override-btn');
            btn.innerText = `Neural Override (‚àû)`;
            btn.disabled = false;
            btn.style.opacity = 1;
        }

        function requestOverride() {
            if (!currentLevel || !currentLevel.solution) return;
            
            // Find all cells that are currently WRONG compared to the solution
            // AND not already currently highlighted by a previous override
            const incorrectCells = [];
            for (let y = 0; y < currentLevel.height; y++) {
                for (let x = 0; x < currentLevel.width; x++) {
                    const alreadyHighlighted = overridePending.some(p => p.x === x && p.y === y);
                    if (state[y][x] !== currentLevel.solution[y][x] && !alreadyHighlighted) {
                        incorrectCells.push({x, y});
                    }
                }
            }

            if (incorrectCells.length === 0) return;

            // Pick up to 3 random incorrect cells
            const count = Math.min(3, incorrectCells.length);
            for (let i = 0; i < count; i++) {
                const idx = Math.floor(Math.random() * incorrectCells.length);
                overridePending.push(incorrectCells.splice(idx, 1)[0]);
            }

            updateOverrideButton();
            updateUI();
        }

        function shareResult() {
            if (!currentLevel) return;
            const uid = currentLevel.id;
            const moves = history.length + 1; // Basic move count
            const status = "Origin Identified";
            const url = window.location.href;
            
            // Generate a simple emoji representation of the grid
            let gridEmoji = "";
            for (let y = 0; y < currentLevel.height; y++) {
                for (let x = 0; x < currentLevel.width; x++) {
                    gridEmoji += state[y][x] === 1 ? "üü©" : "‚¨ú";
                }
                gridEmoji += "\n";
            }

            const text = `Proxima 8: ${currentLevel.title}\nUID: ${uid}\nMoves: ${moves}\n${status}\n\nhttps://fifthrace.github.io/proxima8/`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'Proxima 8 Mapping',
                    text: text,
                    url: url
                }).catch(console.error);
            } else {
                navigator.clipboard.writeText(text).then(() => {
                    alert("Mapping copied to clipboard!");
                });
            }
        }

        function resetGame() {
            if (!currentLevel) return;
            if (confirm("Clear this map?")) {
                history = [];
                state = Array(currentLevel.height).fill().map(() => Array(currentLevel.width).fill(0));
                clearInProgress(currentLevel.id);
                unmarkCompleted(currentLevel.id);
                updateUI();
                checkWin();
            }
        }

        function copyUID() {
            const uidText = currentLevel.id;
            navigator.clipboard.writeText(uidText);
            const el = document.getElementById('level-id-display');
            const oldText = el.innerText;
            el.innerText = "Copied!";
            setTimeout(() => el.innerText = oldText, 1000);
        }

        function nextLevel() {
            if (!currentLevel || levelManifest.length === 0) return;
            
            const currentIndex = levelManifest.findIndex(l => l.id === currentLevel.id);
            let nextIndex = currentIndex + 1;
            
            // Loop back to start if at the end
            if (nextIndex >= levelManifest.length) nextIndex = 0;
            
            loadLevel(levelManifest[nextIndex].id);
        }

        // Boot
        async function boot() {
            await fetchManifest();
            
            window.onpopstate = () => {
                const urlParams = new URLSearchParams(window.location.search);
                loadLevel(urlParams.get('level'));
            };
            
            const urlParams = new URLSearchParams(window.location.search);
            const initialLevel = urlParams.get('level');
            if (initialLevel) {
                loadLevel(initialLevel);
            } else {
                showMenu();
            }
        }
        
        boot();
    </script>
</body>
</html>
